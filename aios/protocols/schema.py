from __future__ import annotations
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Union

from pydantic import BaseModel, Field

# --- Base Model ---
class AIOSBaseModel(BaseModel):
    """Base model for all AIOS events, includes timestamp and version."""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    version: int = 1

# --- Observer Schemas (Raw Signals) ---
class ScreenshotData(BaseModel):
    """Data specific to a screenshot raw signal."""
    format: Literal["png", "jpeg"] = "png"
    screen_size: tuple[int, int]

class UIATreeData(BaseModel):
    """Data specific to a UIA tree raw signal."""
    focused_window_title: str
    tree_structure: Dict[str, Any] # A nested dict representing the UIA tree

class LogData(BaseModel):
    """Data specific to a log tail raw signal."""
    log_source: str # e.g., the path to the tailed file
    new_lines: List[str]

class RawSignal(AIOSBaseModel):
    """A single raw signal from an observer."""
    observer_id: str # e.g., "screenshot_observer_1"
    artifact_path: str # Path to the raw artifact (e.g., image file, full UIA json)
    artifact_hash: str # SHA256 hash of the artifact
    data: Union[ScreenshotData, UIATreeData, LogData]

# --- Protocol1 Schema ---
class ObservationEvent(AIOSBaseModel):
    """A structured observation event, the output of Protocol1."""
    observation_id: str
    raw_signals: List[RawSignal]
    
    # Parsed and structured data (simulated by LLM/rules)
    ui_state_summary: str
    environment_state_summary: str
    potential_intent: str

class LLMResponseMock(AIOSBaseModel):
    """
    Mock structure for an LLM response that would contain structured
    observation data. This helps in validating the mock output.
    """
    ui_state_summary: str
    environment_state_summary: str
    potential_intent: str

# --- Graph Memory Schema ---
class GraphUpdate(AIOSBaseModel):
    """
    Represents an update event to the Interaction Graph memory.
    Logged to the event stream to allow graph reconstruction and audit.
    """
    observation_id: str # The observation that triggered this graph update
    summary_of_change: str # A human-readable summary of what changed in the graph
    metadata: Dict[str, Any] = Field(default_factory=dict) # Flexible metadata for future use

# --- Protocol2 Schema ---

class TypeStringParameters(BaseModel):
    text: str

class KeyPressParameters(BaseModel):
    key: str # e.g., "space", "enter", "up", "down"
    modifiers: List[str] = Field(default_factory=list) # e.g., ["shift", "ctrl"]

class MouseClickParameters(BaseModel):
    x: int
    y: int
    button: Literal["left", "right", "middle"] = "left"
    clicks: int = 1

class ActionPlan(AIOSBaseModel):
    """An action plan generated by the Agent, the input to Protocol2."""
    action_id: str
    origin_observation_id: str
    action_type: Literal["TypeString", "KeyPress", "MouseClick", "Log", "NoAction"] # Explicitly list supported actions
    parameters: Union[TypeStringParameters, KeyPressParameters, MouseClickParameters, Dict[str, Any]] # Use Union for specific parameter models
    constraints: Dict[str, Any] = Field(default_factory=dict)
    dry_run: bool = True

# --- Actuator Schema ---
class Receipt(AIOSBaseModel):
    """A receipt returned by an Actuator after executing an action."""
    action_id: str
    status: Literal["success", "failure", "rejected_unsafe", "dry_run_success"]
    message: str
    latency_ms: float

# --- Event Stream Wrapper ---
class EventType(str, Enum):
    OBSERVATION = "OBSERVATION"
    ACTION = "ACTION"
    RECEIPT = "RECEIPT"
    GRAPH_UPDATE = "GRAPH_UPDATE" # ADDED

class Event(AIOSBaseModel):
    """A generic wrapper for any event in the system's JSONL log."""
    event_id: str
    event_type: EventType
    payload: Union[ObservationEvent, ActionPlan, Receipt, GraphUpdate] # ADDED GraphUpdate
